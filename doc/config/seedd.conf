# Example configuration file for seedd.

# Application-wide options are defined in this section.  All options set
# here do the same thing as the command line options with the same name.
[Service]
 # Fork to the background and run as a daemon (--daemon).
 # You should not need (or want) to set this here for a process which is
 # expected to be managed by systemd or a SysV init script, you should let
 # their configuration control how it is to be placed into the background.
 # But you might use this if you want to manually background a separate
 # process run directly from the command line.
 #daemon

 # Feed entropy to the OS kernel (--kernel).
 kernel

 # When listening on an IP socket, don't require the needed network interface
 # to already be up.  This allows seedd to be started early, without waiting
 # for network configuration to occur even when it should listen on a specific
 # address.  If this option is not enabled, then it is a fatal error for the
 # udp-out service or a TCP control-socket to be bound to an address which is
 # not already configured when seedd is started.
 ip-freebind

 # Provide a UDP socket for entropy output on port 12345 of 127.0.0.1.
 #udp-out		127.0.0.1:12345

 # Where to create the service control socket (used by bbctl and munin etc.).
 # May be set to 'none' to not create a control socket at all.  If this option
 # is used to change the default control-socket address, then you will also
 # need to explicitly specify the new address to other tools accessing it too.
 #control-socket	/run/bit-babbler/seedd.socket

 # Give users in this system group permission to access the control socket.
 socket-group		adm

 # Request more or less information to be logged about what is going on.
 # This may be changed on the fly at runtime with `bbctl --log-verbosity`
 # if the control socket is available.
 #verbose		3


# Options to configure the entropy collection pool.
# You normally shouldn't need to change or set anything here unless you have
# very special requirements and know exactly what you are doing and why.
#[Pool]
 # The size of the internal entropy pool in bytes (--pool-size).
 #size			64k

 # The device node used to feed fresh entropy to the OS kernel.
 #kernel-device		/dev/random

 # The maximum time in seconds before fresh entropy will be added to the OS
 # kernel, even when it hasn't drained below its usual refill threshold.
 #kernel-refill		60


# Define an entropy collecting group and the size of its pool (--group-size).
# The group_number is the integer given after the PoolGroup: string, and is the
# value used for the Device 'group' option to assign a device to that group.
# Pool groups can be used when multiple BitBabbler devices are available to
# optimise for throughput or redundancy.  If you only have a single device,
# you probably don't need to define any groups explicitly.  By default all
# devices are placed into group 0 unless otherwise configured.
# Any number of pool groups that are needed may be defined.
#[PoolGroup:0]
# size			64k

#[PoolGroup:1]
# size			64k


# This section configures the defaults to use for all BitBabbler devices which
# don't override them in a per-device section (or on the command line).
# All options set here do the same thing as the command line options with the
# same name when passed before any --device-id option.
#[Devices]
 # The rate in bits per second at which to clock raw bits out of the device.
 #bitrate		2.5M

 # Override the calculated value for the USB latency timer.
 #latency		5

 # Set the number of times to fold the BitBabbler output before adding it to
 # the pool.  The default for this depends on the device type.  White devices
 # default to folding just once, Black devices with only a single generator
 # will fold 3 times to emulate the four generators on the White devices.
 #fold			3

 # The entropy PoolGroup to add the device to.
 #group			0

 # Select a subset of the generators on BitBabbler devices with multiple
 # entropy sources.  The argument is a bitmask packed from the LSB, with each
 # bit position controlling an individual source, enabling it when set to 1.
 # There is usually no good reason to mask generators in normal use, the main
 # use case is to verify the output of each generator separately when testing.
 #enable-mask		0x0f

 # Configure how devices back off from generating entropy at the maximum rate
 # when it is not actually being consumed by anything.  When the pool first
 # becomes full, we will pause for the 'initial' number of milliseconds,
 # doubling that delay each time we wake with the pool still full up to the
 # maximum value.  As a special case, if the max value is 0 then further reads
 # from the device will be suspended indefinitely once the delay reaches 512ms
 # until the pool is no longer full.
 #idle-sleep		100:60000

 # The threshold in milliseconds where if we expect the device to be idle for
 # longer than that, we will release our claim on it, allowing the OS to put
 # it into a low power mode while it is not being used.  A value of 0 means
 # we will never release the claim unless seedd is halted or it is unplugged.
 #suspend-after		0

 # Enable options for better power saving on lightly loaded systems.
 # This is equivalent to using:
 #  -kernel-refill=3600 --idle-sleep=100:0 --suspend-after=10000
 # Which should be a reasonable balance of allowing the system to suspend as
 # much as possbile when idle while keeping sufficient fresh entropy on hand
 # for when it is needed.
 #low-power

 # Limit the maximum transfer chunk size to 16kB.  This is a workaround for
 # buggy USB chipsets (and their drivers) which still do exist on some
 # motherboards and have trouble when larger transfers are used.  The impact
 # on transfer speed of this is relatively minimal, but you normally wouldn't
 # want to enable this unless you actually see real problems without it.
 #limit-max-xfer

 # Disable gating entropy output on the result of quality and health checking.
 # You almost never want to use this option at all, and even less so in a
 # configuration file for a system daemon.  The main reason this option exists
 # at all is for generating streams which are to be analysed for quality by
 # some external test suite - in which case we definitely don't want to be
 # filtering any bad blocks of bits from what it would see.  But you'd never
 # want to do this for any 'normal' use where good entropy is always assumed.
 # Because of that, this *only* disables the QA gating on bits output via
 # stdout.  And we do support it in this configuration file as that may be a
 # convenient way to record the configuration which is used for such testing.
 #no-qa


# Sections with a Device: prefix can be used to both enable and configure
# individual devices.  The following is the equivalent of passing the command
# line option --device-id=XYZZY and if any options are specified for this
# section, that is equivalent to passing them after the --device-id option in
# that they will only apply to this device and no others.  All the options for
# the [Devices] section above may be used here.
#
# If no [Device:] sections are defined, the default is to operate on all of
# the devices which are available.  It is not an error to define a section for
# a device which is not, or may not be, present at any given time.
#[Device:XYZZY]


# [Watch:] sections can be used to run our QA testing on some other external
# source of random bits, provided we can read them as if they were a file or
# named pipe or device node.  Any number of Watch sections may be defined,
# each just needs its own unique label after the Watch: prefix to identify it.
#
# For example, the following will run QA testing on the /dev/urandom device,
# reading a block of 64kB every 500ms for analysis.  The results of that
# analysis are available from the control socket in the same way as the QA
# reports on bits from the BitBabbler devices and the internal pools are.
#[Watch:urandom]
 # The path to the device/pipe/file to read bits from.  This must be set.
 #path			/dev/urandom

 # How long to wait before reading the next block of bits.  Default 0.
 #delay			500

 # The number of bytes to read between each delay period.  Default 64kB.
 #block-size		64k

 # The maximum number of bytes to read in total.  Default 0 implies reading
 # an 'infinite' number of bits for as long as the process keeps running,
 # which is probably what you usually want when using this.
 #max-bytes		1G

